
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Configura tu partido</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
</head>
<body>

<header>
  <div class="header-content">
    <h2><i class="fa-solid fa-table-tennis-paddle-ball"></i> Configura tu partido</h2>

    <div class="separator"></div>
    
    <!-- Estado de la cancha -->
    <div id="estado-cancha" class="cancha-check">
      <span class="led"></span>
      <span class="texto-estado">COMPROBANDO ...</span>
    </div>
    
    <div id="cancha-msg" class="cancha-mensaje" style="display:none;">
      <p><i class="fa-solid fa-circle-exclamation"></i>
    Partido en curso. Espere a que finalice para configurar uno nuevo. No recargue ni cierre esta p√°gina, de lo contrario deber√° completar nuevamente el formulario.</p>
    </div>

  </div>
</header>




<main>
  <!-- Paso 1: Nombres y pulseras -->
  <section class="step active" id="step1">
    <div class="card">
      <h3>Pareja 1</h3>
      <input type="text" id="p1j1" placeholder="Jugador/a 1">
      <input type="text" id="p1j2" placeholder="Jugador/a 2">
      <label>Pulsera:</label>
      <select id="bracelet-team1" required>
        <option value="" disabled selected hidden class="placeholder">Seleccionar Pulsera</option>
        <option value="roja">Roja</option>
        <option value="azul">Azul</option>
        <option value="verde">Verde</option>
        <option value="amarilla">Amarilla</option>
      </select>
    </div>

    <div class="card">
      <h3>Pareja 2</h3>
      <input type="text" id="p2j1" placeholder="Jugador/a 3">
      <input type="text" id="p2j2" placeholder="Jugador/a 4">
      <label>Pulsera:</label>
      <select id="bracelet-team2" required>
        <option value="" disabled selected hidden class="placeholder">Seleccionar Pulsera</option>
        <option value="roja">Roja</option>
        <option value="azul">Azul</option>
        <option value="verde">Verde</option>
        <option value="amarilla">Amarilla</option>
      </select>
    </div>

    <div class="error-msg" id="step1-error"><i class="fa-solid fa-triangle-exclamation"></i> Ning√∫n campo puede quedar vac√≠o ni repetido.</div>

    <div class="nav-buttons">
      <button class="next" id="step1-next" disabled>Siguiente</button>
    </div>
  </section>

  <!-- Paso 2: Sacadores -->
  <!--  <section class="step" id="step2">
    <div class="card">
      <h3>Elegir sacadores de cada Pareja</h3>
      <div class="separator"></div>

      <h4>Pareja 1</h4>
      <select id="sacador1" required>
        <option value="" disabled selected hidden class="placeholder">Seleccionar Sacador</option>
      </select>

      <div class="separator"></div>

      <h4>Pareja 2</h4>
      <select id="sacador2" required>
        <option value="" disabled selected hidden class="placeholder">Seleccionar Sacador</option>
      </select>

      <div class="error-msg" id="step2-error"><i class="fa-solid fa-triangle-exclamation"></i> Debes seleccionar un sacador para cada pareja.</div>
    </div>

    <div class="nav-buttons">
      <button class="prev">Volver</button>
      <button class="next" id="step2-next" disabled>Siguiente</button>
    </div>
  </section>
-->

  <!-- Paso 3: Modos de juego -->
  <section class="step" id="step3">
    <div class="card">
      <h3>Tiempo de calentamiento</h3>
      <label><input type="radio" name="calentamiento" value="0" required> Sin calentamiento</label>
      <label><input type="radio" name="calentamiento" value="5"> 5 minutos</label>
      <label><input type="radio" name="calentamiento" value="10"> 10 minutos</label>
    </div>

    <div class="card">
      <h3>Cambio de lado</h3>
      <label><input type="radio" name="cambio" value="set" required> Al finalizar cada SET</label>
      <label><input type="radio" name="cambio" value="tradicional"> Tradicional (impares)</label>
      <label><input type="radio" name="cambio" value="ninguno"> Sin cambios</label>
    </div>

    <div class="card">
      <h3>Games</h3>
      <label><input type="radio" name="games" value="punto-oro" required> Punto de oro</label>
      <label><input type="radio" name="games" value="deuce"> Deuce / Advantage</label>
    </div>

    <div class="nav-buttons">
      <button class="prev">Volver</button>
      <button class="next" id="step3-next">Siguiente</button>
    </div>
  </section>

  <!-- Paso 4: Duraci√≥n y comienzo -->
  <section class="step" id="step4">
    <div class="card">
      <h3>Duraci√≥n del partido</h3>
      <select id="duracion" required>
        <option value="30">30 minutos</option>
        <option value="60">1 hora</option>
        <option value="90">1 hora y media</option>
        <option value="120">2 horas</option>
      </select>
    </div>


<div class="card">
  <h3>Inicio y finalizaci√≥n del partido</h3>
  <label>Hora de inicio:</label>
<select id="inicio-partido"></select>
  <label>Hora de finalizaci√≥n:</label>
  <input type="text" id="fin-partido" readonly>
</div>


    <div class="nav-buttons">
      <button class="prev">Volver</button>
      <button class="finish">Finalizar</button>
    </div>
  </section>
</main>
<script src="/socket.io/socket.io.js"></script>
<script>

// SOCKET IO ============================================

const urlParams = new URLSearchParams(window.location.search);
const RASPY_ID = urlParams.get("id");

if (!RASPY_ID) {
  alert("Error: no se recibi√≥ el ID de la Raspy.");
}

const socket = io();

let estadoRecibido = false;
let ultimaRespuesta = Date.now();

// Avisamos al servidor qu√© Raspy queremos recibir
socket.emit("consultar_raspy", { raspy_id: RASPY_ID });

// Escuchamos el estado de cancha
socket.on(`estado_cancha_${RASPY_ID}`, (data) => {
  ultimaRespuesta = Date.now(); // ‚úÖ lleg√≥ algo, actualizamos timestamp
  console.log("üì° Estado recibido desde VPS:", data);
  estadoRecibido = true;

  if (data.enEspera === false) {
    // Partido en curso
    setEstadoCancha(true);
  } else if (data.enEspera === true) {
    // Cancha libre
    setEstadoCancha(false);
  } else {
    // Raspy no responde o campo ausente
    setEstadoCanchaDesconectada();
  }
});

// Si no se recibe estado en los primeros 3 segundos => sin conexi√≥n inicial
setTimeout(() => {
  if (!estadoRecibido) {
    setEstadoCanchaDesconectada();
  }
}, 3000);

// ===================== PING PERI√ìDICO =====================
// Cada X segundos pedimos el estado actual de la Raspy al servidor
const INTERVALO_PING = 5000; // 5 segundos

setInterval(() => {
  socket.emit("consultar_raspy", { raspy_id: RASPY_ID });

  // Si pasaron m√°s de 10 segundos sin respuesta, marcamos sin conexi√≥n
  if (Date.now() - ultimaRespuesta > 10000) {
    console.warn("‚ö†Ô∏è No se recibi√≥ respuesta del marcador en los √∫ltimos 10s");
    setEstadoCanchaDesconectada();
  }
}, INTERVALO_PING);

// ===================== CANCHA DESCONECTADA =====================
function setEstadoCanchaDesconectada() {
  estadoCancha.classList.remove("cancha-libre", "cancha-ocupada", "cancha-check");
  estadoCancha.classList.add("cancha-desconectada");
  estadoCancha.querySelector(".texto-estado").textContent = "SIN CONEXI√ìN";
  canchaMsg.style.display = "none";

  finishBtn.disabled = true; // üîπ nunca permitir enviar si no hay conexi√≥n
}


// ===================== DETECCI√ìN DE CONEXI√ìN =====================

// Cuando el socket se desconecta del servidor (por ca√≠da de VPS o red)
socket.on("disconnect", () => {
  console.warn("üî¥ Conexi√≥n Socket.IO perdida");
  setEstadoCanchaDesconectada();
});

// Cuando el socket vuelve a conectar
socket.on("connect", () => {
  console.log("üü¢ Reconectado con el servidor");
  socket.emit("consultar_raspy", { raspy_id: RASPY_ID });
});


// ===================== VARIABLES GLOBALES =====================
const step1NextBtn = document.getElementById("step1-next");
const estadoCancha = document.getElementById("estado-cancha");
const canchaMsg = document.getElementById("cancha-msg");
const duracionSelect = document.getElementById("duracion");
const finishBtn = document.querySelector("#step4 .finish");
const inputInicio = document.getElementById("inicio-partido");
const inputFin = document.getElementById("fin-partido");
let pulserasDisponibles = {}; // guardamos lo que viene del JSON
const step1Error = document.getElementById("step1-error");
const inputsStep1 = [
  document.getElementById("p1j1"),
  document.getElementById("p1j2"),
  document.getElementById("p2j1"),
  document.getElementById("p2j2")
];
const selectsStep1 = [
  document.getElementById("bracelet-team1"),
  document.getElementById("bracelet-team2")
];

const step3NextBtn = document.getElementById("step3-next");
const radiosCalentamiento = document.getElementsByName("calentamiento");
const radiosCambio = document.getElementsByName("cambio");
const radiosGames = document.getElementsByName("games");

const steps = document.querySelectorAll(".step");
let current = 0;
let canchaOcupada = false;

let datosHorarios = {
  inicioTexto: '',
  finTexto: '',
  inicioFecha: '',
  finFecha: ''
};

let datosPartido = {
  jugadores: {
    pareja1: { j1: '', j2: '', pulsera: '' },
    pareja2: { j1: '', j2: '', pulsera: '' }
  },
  sacadores: {
    pareja1: '',
    pareja2: ''
  },
  modosJuego: {
    calentamiento: '',
    cambio: '',
    games: ''
  },
  duracion: '',
  comienzo: 'Hoy 20:00'
};

// ===================== INICIALIZACI√ìN =====================
window.addEventListener("DOMContentLoaded", () => {
  // Reset inputs, selects y radios
  document.querySelectorAll('input[type="text"]').forEach(i => i.value = '');
  document.querySelectorAll('select').forEach(s => s.selectedIndex = 0);
  document.querySelectorAll('input[type="radio"]').forEach(r => r.checked = false);

  // Deshabilitar bot√≥n Step1 por defecto
  step1NextBtn.disabled = true;

  // Cargar pulseras desde bracelets.json
  fetch("bracelets.json")
    .then(r => r.json())
    .then(data => {
      pulserasDisponibles = data;
      llenarPulseras();
    })
    .catch(err => console.error("Error cargando pulseras:", err));
});

// ===================== RELLENAR PULSERAS =================

function llenarPulseras() {
  selectsStep1.forEach(sel => {
    sel.innerHTML = '<option value="" disabled selected hidden class="placeholder">Seleccionar Pulsera</option>';
    Object.entries(pulserasDisponibles).forEach(([nombre, mac]) => {
      const opt = document.createElement("option");
      opt.value = nombre;
      opt.textContent = `${nombre} (${mac})`;
      sel.appendChild(opt);
    });
  });
}


// ===================== CANCHA =====================
function validateFinalizar() {
  const step4Valido = duracionSelect.value;
  finishBtn.disabled = !(step4Valido && !canchaOcupada);
}



function setEstadoCancha(ocupada) {
  canchaOcupada = ocupada;

  // üîπ Limpieza de estados previos
  estadoCancha.classList.remove("cancha-desconectada", "cancha-check");

  if (ocupada) {
    estadoCancha.classList.remove("cancha-libre");
    estadoCancha.classList.add("cancha-ocupada");
    estadoCancha.querySelector(".texto-estado").textContent = "CANCHA NO DISPONIBLE";
    canchaMsg.style.display = "flex";
  } else {
    estadoCancha.classList.remove("cancha-ocupada");
    estadoCancha.classList.add("cancha-libre");
    estadoCancha.querySelector(".texto-estado").textContent = "CANCHA DISPONIBLE";
    canchaMsg.style.display = "none";
  }

  // üîπ Bloquear bot√≥n Finalizar si la cancha no est√° libre
  finishBtn.disabled = canchaOcupada || !duracionSelect.value;
}

// ===================== STEP 1 =====================

function validateStep1() {
// ==================================================

sendToServer(datosCompat); // con la funci√≥n definida as√≠:
const sendToServer = (datos) => {
  fetch('/api/config', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(datos)
  })
  .then(res => res.json())
  .then(console.log)
  .catch(console.error);
};  let valid = true;
  step1Error.style.display = "none";
  const values = [];

  // jugadores
  inputsStep1.forEach(inp => {
    inp.classList.remove("error");
    if(!inp.value.trim()) valid = false;
    values.push(inp.value.trim());
  });

  // pulseras
  const pulserasElegidas = [];
  selectsStep1.forEach(sel => {
    sel.classList.remove("error");
    if(!sel.value) valid = false;
    pulserasElegidas.push(sel.value);
  });

  // jugadores duplicados
  const duplicates = values.filter((v,i,a) => v && a.indexOf(v) !== i);
  if(duplicates.length > 0){
    valid = false;
    inputsStep1.forEach(inp => {
      if(duplicates.includes(inp.value.trim())) inp.classList.add("error");
    });
  }

  // pulseras duplicadas
  if (pulserasElegidas[0] && pulserasElegidas[1] && pulserasElegidas[0] === pulserasElegidas[1]) {
    valid = false;
    selectsStep1.forEach(sel => sel.classList.add("error"));
  }

  step1Error.style.display = valid ? "none" : "block";
  step1NextBtn.disabled = !valid;
}


function updateDatosStep1() {
  datosPartido.jugadores.pareja1.j1 = inputsStep1[0].value.trim();
  datosPartido.jugadores.pareja1.j2 = inputsStep1[1].value.trim();
  datosPartido.jugadores.pareja2.j1 = inputsStep1[2].value.trim();
  datosPartido.jugadores.pareja2.j2 = inputsStep1[3].value.trim();

  datosPartido.jugadores.pareja1.pulsera = selectsStep1[0].value;
  datosPartido.jugadores.pareja2.pulsera = selectsStep1[1].value;

  validateStep1();
}

function populateStep1() {
  inputsStep1[0].value = datosPartido.jugadores.pareja1.j1;
  inputsStep1[1].value = datosPartido.jugadores.pareja1.j2;
  inputsStep1[2].value = datosPartido.jugadores.pareja2.j1;
  inputsStep1[3].value = datosPartido.jugadores.pareja2.j2;
  selectsStep1[0].value = datosPartido.jugadores.pareja1.pulsera || '';
  selectsStep1[1].value = datosPartido.jugadores.pareja2.pulsera || '';
  validateStep1();
}

inputsStep1.forEach(i => i.addEventListener("input", updateDatosStep1));
selectsStep1.forEach(s => s.addEventListener("change", updateDatosStep1));

// ===================== STEP 3 =====================
function validateRadios(radios) {
  return Array.from(radios).some(r => r.checked);
}

function validateStep3() {
  const valid = validateRadios(radiosCalentamiento) &&
                validateRadios(radiosCambio) &&
                validateRadios(radiosGames);
  step3NextBtn.disabled = !valid;
}

function updateDatosStep3() {
  datosPartido.modosJuego.calentamiento = document.querySelector('input[name="calentamiento"]:checked')?.value || '';
  datosPartido.modosJuego.cambio = document.querySelector('input[name="cambio"]:checked')?.value || '';
  datosPartido.modosJuego.games = document.querySelector('input[name="games"]:checked')?.value || '';
  validateStep3();
}

function populateStep3() {
  radiosCalentamiento.forEach(r => r.checked = r.value===datosPartido.modosJuego.calentamiento);
  radiosCambio.forEach(r => r.checked = r.value===datosPartido.modosJuego.cambio);
  radiosGames.forEach(r => r.checked = r.value===datosPartido.modosJuego.games);
  validateStep3();
}

[...radiosCalentamiento, ...radiosCambio, ...radiosGames].forEach(r => r.addEventListener("change", updateDatosStep3));

// ===================== STEP 4 =====================
// Inicializamos fin vac√≠o
inputFin.value = '';

// Mensaje de error debajo del select de duraci√≥n
const step4Error = document.createElement("div");
step4Error.classList.add("error-msg");
step4Error.innerHTML = '<i class="fa-solid fa-triangle-exclamation"></i> Debes seleccionar la duraci√≥n del partido';
duracionSelect.parentNode.appendChild(step4Error);

// ===================== FUNCIONES DE HORARIOS =====================


function generateTimeOptions() {
  const now = new Date();
  let hour = now.getHours();
  let minutes = now.getMinutes();

  // Determinar el pr√≥ximo horario v√°lido (redondeo a la media hora)
  let validHour = hour;
  let validMinutes = minutes;
  if (minutes <= 15) validMinutes = 0;
  else if (minutes <= 45) validMinutes = 30;
  else { validMinutes = 0; validHour += 1; }
  if (validHour >= 24) validHour -= 24;

  const defaultTime = `${validHour.toString().padStart(2,'0')}:${validMinutes.toString().padStart(2,'0')}`;

  const options = [];
  // Generar opciones: media hora antes hasta 1 hora adelante
  const totalSlots = 3; // -1, 0, +1, +2
  for (let i = -1; i <= 2; i++) {
    let totalMinutes = validHour * 60 + validMinutes + i * 30;
    let h = Math.floor(totalMinutes / 60);
    let m = totalMinutes % 60;
    if (h < 0) h += 24;
    if (h >= 24) h -= 24;
    options.push(`${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`);
  }

  return { options, defaultTime };
}

function validarHorarioLogico() {
  const ahora = new Date();
  const [hInicio, mInicio] = inputInicio.value.split(':').map(Number);
  const inicio = new Date();
  inicio.setHours(hInicio, mInicio, 0, 0);

  // Si no hay duraci√≥n seleccionada todav√≠a, no validamos
  if (!duracionSelect.value) return true;

  const fin = new Date(inicio.getTime() + parseInt(duracionSelect.value) * 60000);

  // ‚ö†Ô∏è Si el horario de fin ya pas√≥, mostramos error y bloqueamos el bot√≥n finalizar
  if (fin <= ahora) {
    step4Error.style.display = "block";
    step4Error.innerHTML = `<i class="fa-solid fa-triangle-exclamation"></i> El horario de finalizaci√≥n no es v√°lido. Por favor, modific√° la hora de inicio o la duraci√≥n del partido.`;
    duracionSelect.classList.add("error");
    finishBtn.disabled = true;
    return false;
  } else {
    // restauramos mensaje original si todo est√° bien
    step4Error.innerHTML = '<i class="fa-solid fa-triangle-exclamation"></i> Debes seleccionar la duraci√≥n del partido';
    validateStep4();
    return true;
  }
}

function updateInicioSelect() {
  const { options, defaultTime } = generateTimeOptions();
  const previousValue = inputInicio.value; // lo que el usuario ya seleccion√≥
  inputInicio.innerHTML = ''; // limpiar select

  let selectionStillValid = previousValue && options.includes(previousValue);

  options.forEach(opt => {
    const el = document.createElement('option');
    el.value = opt;
    el.textContent = opt;
    // solo seleccionamos si es la selecci√≥n previa v√°lida o si no hay previa
    if(selectionStillValid) {
      if(opt === previousValue) el.selected = true;
    } else {
      if(opt === defaultTime) el.selected = true;
    }
    inputInicio.appendChild(el);
  });

  // actualizar fin autom√°ticamente
  updateFin();
}

function updateFin() {
  if (!duracionSelect.value) {
    inputFin.value = '';
    return;
  }
  const [h, m] = inputInicio.value.split(':').map(Number);
  const inicio = new Date();
  inicio.setHours(h, m, 0, 0);

  const fin = new Date(inicio.getTime() + parseInt(duracionSelect.value) * 60000);

  inputFin.value = `${fin.getHours().toString().padStart(2,'0')}:${fin.getMinutes().toString().padStart(2,'0')}`;

  // Guardamos los datos detallados
  datosHorarios = {
    inicioTexto: inputInicio.value,
    finTexto: inputFin.value,
    inicioFecha: inicio.toISOString(),
    finFecha: fin.toISOString()
  };
}


// Llamamos a esta funci√≥n cada vez que cargamos Step4 o cada X segundos si queremos que se actualice din√°micamente
setInterval(updateInicioSelect, 60000); // cada minuto

// Validaci√≥n de Step 4
function validateStep4() {
  if(duracionSelect.value){
    step4Error.style.display = "none";
    duracionSelect.classList.remove("error");
  } else {
    step4Error.style.display = "block";
    duracionSelect.classList.add("error");
  }
  validateFinalizar(); // habilita/deshabilita bot√≥n Finalizar seg√∫n cancha y duraci√≥n
}

// Poblado inicial de Step 4
function populateStep4() {
  duracionSelect.value = datosPartido.duracion || '';
  validateStep4();
  updateInicioSelect();
}

// ===================== EVENTOS =====================
duracionSelect.addEventListener("change", () => {
  datosPartido.duracion = duracionSelect.value;
  validateStep4();
  updateFin();
  validarHorarioLogico();
});

// Cuando el usuario cambia manualmente el inicio
inputInicio.addEventListener('change', () => {
  updateFin();
  validarHorarioLogico();
});

// Actualizaci√≥n autom√°tica cada 60 segundos
setInterval(updateInicioSelect, 60000);
updateInicioSelect(); // inicial al cargar

// ===================== NAVEGACI√ìN =====================
function showStep(index){
  steps.forEach((s,i)=>s.classList.toggle("active", i===index));
  current = index;
  if(index===0) populateStep1();
//  if(index===1) populateStep2(); //SI LA REACTIVAS FIJATE LOS INDICES
  if(index===1) populateStep3();
  if(index===2) populateStep4();
}

document.querySelectorAll(".next").forEach(btn => btn.addEventListener("click", ()=>{ if(current<steps.length-1) showStep(current+1); }));
document.querySelectorAll(".prev").forEach(btn => btn.addEventListener("click", ()=>{ if(current>0) showStep(current-1); }));

// ==================================================
// FINALIZAR Y ENVIAR AL SERVIDOR
// ==================================================
finishBtn.addEventListener("click", () => {
  const datosCompat = {
    jugadores: [
      datosPartido.jugadores.pareja1.j1,
      datosPartido.jugadores.pareja1.j2,
      datosPartido.jugadores.pareja2.j1,
      datosPartido.jugadores.pareja2.j2
    ],
    parejas: {
      pareja1: [
        datosPartido.jugadores.pareja1.j1,
        datosPartido.jugadores.pareja1.j2
      ],
      pareja2: [
        datosPartido.jugadores.pareja2.j1,
        datosPartido.jugadores.pareja2.j2
      ]
    },

    parejaSacadora: "pareja1", // si quer√©s pod√©s dejarlo fijo o borrarlo

    // üîπ Sacadores vac√≠o
    sacadores: ["", ""],

    tiempoCalentamiento: (() => {
      switch (datosPartido.modosJuego.calentamiento) {
        case "0": return "Sin calentamiento";
        case "5": return "5 minutos";
        case "10": return "10 minutos";
        default: return "";
      }
    })(),
    cambioDeLado: (() => {
      switch (datosPartido.modosJuego.cambio) {
        case "set": return "Al finalizar cada SET";
        case "tradicional": return "Tradicional (impares)";
        case "ninguno": return "Sin cambios";
        default: return "";
      }
    })(),
    tipoGames: (() => {
      switch (datosPartido.modosJuego.games) {
        case "punto-oro": return "Punto de oro";
        case "deuce": return "Deuce / Advantage";
        default: return "";
      }
    })(),

    // üîπ Orden de saque vac√≠o
    ordenDeSaque: ["", "", "", ""],

    // üîπ Info de horarios

    duracion: `${datosPartido.duracion} minutos`,
    comienzo: datosHorarios.inicioTexto,
    fin: datosHorarios.finTexto,
    inicioFecha: datosHorarios.inicioFecha,
    finFecha: datosHorarios.finFecha,



    pulseras: {
     pareja1: {
       nombre: datosPartido.jugadores.pareja1.pulsera,
        mac: pulserasDisponibles[datosPartido.jugadores.pareja1.pulsera] || ""
     },
     pareja2: {
        nombre: datosPartido.jugadores.pareja2.pulsera,
        mac: pulserasDisponibles[datosPartido.jugadores.pareja2.pulsera] || ""
     }
}

saludoPrueba: "HOLA QUE TAL", // <- agregalo aqu√≠

  };

  console.log("üõ†Ô∏è Partido configurado:", datosCompat);
  sendToServer(datosCompat);
});


// ==================================================
// ENVIAR DATOS AL SERVIDOR
// ==================================================

sendToServer = (datosPartido) => {
  // Enviar los datos al servidor para que los reenv√≠e a la Raspy
  fetch('/api/send_raspy', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
          raspy_id: RASPY_ID, //AC√Å MANDAMOS A LA ID DE LA RASPY
          datos: datosPartido
      })
  })
  .then(response => response.json())
  .then(data => {
      console.log('Respuesta del servidor:', data);
      if(data.error) alert(data.error);
  })
  .catch(error => {
      console.error('Error enviando datos al servidor:', error);
      alert("No se pudo enviar la configuraci√≥n. ¬øEl servidor est√° corriendo?");
  });
};
</script>
</body>
</html>

